{"version":3,"file":"index.umd.min.js","sources":["../src/contracts/CounterContract.ts","../src/contracts/TokenfactoryContract.ts"],"sourcesContent":["/**\n* This file was automatically generated by cosmwasm-typescript-gen@0.3.9.\n* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n* and run the cosmwasm-typescript-gen generate command to regenerate this file.\n*/\n\nimport { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from \"@cosmjs/cosmwasm-stargate\";\nimport { Coin, StdFee } from \"@cosmjs/amino\";\nexport type ExecuteMsg = {\n  increment: {\n    [k: string]: unknown;\n  };\n} | {\n  reset: {\n    count: number;\n    [k: string]: unknown;\n  };\n};\nexport interface GetCountResponse {\n  count: number;\n  [k: string]: unknown;\n}\nexport interface InstantiateMsg {\n  count: number;\n  [k: string]: unknown;\n}\nexport type QueryMsg = {\n  get_count: {\n    [k: string]: unknown;\n  };\n};\nexport type Addr = string;\nexport interface State {\n  count: number;\n  owner: Addr;\n  [k: string]: unknown;\n}\nexport interface CounterReadOnlyInterface {\n  contractAddress: string;\n  getCount: () => Promise<GetCountResponse>;\n}\nexport class CounterQueryClient implements CounterReadOnlyInterface {\n  client: CosmWasmClient;\n  contractAddress: string;\n\n  constructor(client: CosmWasmClient, contractAddress: string) {\n    this.client = client;\n    this.contractAddress = contractAddress;\n    this.getCount = this.getCount.bind(this);\n  }\n\n  getCount = async (): Promise<GetCountResponse> => {\n    return this.client.queryContractSmart(this.contractAddress, {\n      get_count: {}\n    });\n  };\n}\nexport interface CounterInterface extends CounterReadOnlyInterface {\n  contractAddress: string;\n  sender: string;\n  increment: (fee?: number | StdFee | \"auto\", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;\n  reset: ({\n    count\n  }: {\n    count: number;\n  }, fee?: number | StdFee | \"auto\", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;\n}\nexport class CounterClient extends CounterQueryClient implements CounterInterface {\n  client: SigningCosmWasmClient;\n  sender: string;\n  contractAddress: string;\n\n  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {\n    super(client, contractAddress);\n    this.client = client;\n    this.sender = sender;\n    this.contractAddress = contractAddress;\n    this.increment = this.increment.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  increment = async (fee: number | StdFee | \"auto\" = \"auto\", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {\n    return await this.client.execute(this.sender, this.contractAddress, {\n      increment: {}\n    }, fee, memo, funds);\n  };\n  reset = async ({\n    count\n  }: {\n    count: number;\n  }, fee: number | StdFee | \"auto\" = \"auto\", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {\n    return await this.client.execute(this.sender, this.contractAddress, {\n      reset: {\n        count\n      }\n    }, fee, memo, funds);\n  };\n}","/**\n* This file was automatically generated by cosmwasm-typescript-gen@0.3.9.\n* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n* and run the cosmwasm-typescript-gen generate command to regenerate this file.\n*/\n\nimport { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from \"@cosmjs/cosmwasm-stargate\";\nimport { Coin, StdFee } from \"@cosmjs/amino\";\nexport type ExecuteMsg = {\n  create_denom: {\n    subdenom: string;\n    [k: string]: unknown;\n  };\n} | {\n  change_admin: {\n    denom: string;\n    new_admin_address: string;\n    [k: string]: unknown;\n  };\n} | {\n  mint_tokens: {\n    amount: Uint128;\n    denom: string;\n    mint_to_address: string;\n    [k: string]: unknown;\n  };\n} | {\n  burn_tokens: {\n    amount: Uint128;\n    burn_from_address: string;\n    denom: string;\n    [k: string]: unknown;\n  };\n};\nexport type Uint128 = string;\nexport interface GetDenomResponse {\n  denom: string;\n  [k: string]: unknown;\n}\nexport interface InstantiateMsg {\n  [k: string]: unknown;\n}\nexport type QueryMsg = {\n  get_denom: {\n    creator_address: string;\n    subdenom: string;\n    [k: string]: unknown;\n  };\n};\nexport type Addr = string;\nexport interface State {\n  owner: Addr;\n  [k: string]: unknown;\n}\nexport interface TokenfactoryReadOnlyInterface {\n  contractAddress: string;\n  getDenom: ({\n    creatorAddress,\n    subdenom\n  }: {\n    creatorAddress: string;\n    subdenom: string;\n  }) => Promise<GetDenomResponse>;\n}\nexport class TokenfactoryQueryClient implements TokenfactoryReadOnlyInterface {\n  client: CosmWasmClient;\n  contractAddress: string;\n\n  constructor(client: CosmWasmClient, contractAddress: string) {\n    this.client = client;\n    this.contractAddress = contractAddress;\n    this.getDenom = this.getDenom.bind(this);\n  }\n\n  getDenom = async ({\n    creatorAddress,\n    subdenom\n  }: {\n    creatorAddress: string;\n    subdenom: string;\n  }): Promise<GetDenomResponse> => {\n    return this.client.queryContractSmart(this.contractAddress, {\n      get_denom: {\n        creator_address: creatorAddress,\n        subdenom\n      }\n    });\n  };\n}\nexport interface TokenfactoryInterface extends TokenfactoryReadOnlyInterface {\n  contractAddress: string;\n  sender: string;\n  createDenom: ({\n    subdenom\n  }: {\n    subdenom: string;\n  }, fee?: number | StdFee | \"auto\", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;\n  changeAdmin: ({\n    denom,\n    newAdminAddress\n  }: {\n    denom: string;\n    newAdminAddress: string;\n  }, fee?: number | StdFee | \"auto\", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;\n  mintTokens: ({\n    amount,\n    denom,\n    mintToAddress\n  }: {\n    amount: string;\n    denom: string;\n    mintToAddress: string;\n  }, fee?: number | StdFee | \"auto\", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;\n  burnTokens: ({\n    amount,\n    burnFromAddress,\n    denom\n  }: {\n    amount: string;\n    burnFromAddress: string;\n    denom: string;\n  }, fee?: number | StdFee | \"auto\", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;\n}\nexport class TokenfactoryClient extends TokenfactoryQueryClient implements TokenfactoryInterface {\n  client: SigningCosmWasmClient;\n  sender: string;\n  contractAddress: string;\n\n  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {\n    super(client, contractAddress);\n    this.client = client;\n    this.sender = sender;\n    this.contractAddress = contractAddress;\n    this.createDenom = this.createDenom.bind(this);\n    this.changeAdmin = this.changeAdmin.bind(this);\n    this.mintTokens = this.mintTokens.bind(this);\n    this.burnTokens = this.burnTokens.bind(this);\n  }\n\n  createDenom = async ({\n    subdenom\n  }: {\n    subdenom: string;\n  }, fee: number | StdFee | \"auto\" = \"auto\", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {\n    return await this.client.execute(this.sender, this.contractAddress, {\n      create_denom: {\n        subdenom\n      }\n    }, fee, memo, funds);\n  };\n  changeAdmin = async ({\n    denom,\n    newAdminAddress\n  }: {\n    denom: string;\n    newAdminAddress: string;\n  }, fee: number | StdFee | \"auto\" = \"auto\", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {\n    return await this.client.execute(this.sender, this.contractAddress, {\n      change_admin: {\n        denom,\n        new_admin_address: newAdminAddress\n      }\n    }, fee, memo, funds);\n  };\n  mintTokens = async ({\n    amount,\n    denom,\n    mintToAddress\n  }: {\n    amount: string;\n    denom: string;\n    mintToAddress: string;\n  }, fee: number | StdFee | \"auto\" = \"auto\", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {\n    return await this.client.execute(this.sender, this.contractAddress, {\n      mint_tokens: {\n        amount,\n        denom,\n        mint_to_address: mintToAddress\n      }\n    }, fee, memo, funds);\n  };\n  burnTokens = async ({\n    amount,\n    burnFromAddress,\n    denom\n  }: {\n    amount: string;\n    burnFromAddress: string;\n    denom: string;\n  }, fee: number | StdFee | \"auto\" = \"auto\", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {\n    return await this.client.execute(this.sender, this.contractAddress, {\n      burn_tokens: {\n        amount,\n        burn_from_address: burnFromAddress,\n        denom\n      }\n    }, fee, memo, funds);\n  };\n}"],"names":["CounterQueryClient","client","contractAddress","_this","this","getCount","__awaiter","queryContractSmart","get_count","bind","CounterClient","_super","sender","call","increment","fee","memo","funds","execute","_a","reset","count","_b","__extends","TokenfactoryQueryClient","getDenom","creatorAddress","subdenom","get_denom","creator_address","TokenfactoryClient","createDenom","create_denom","changeAdmin","denom","newAdminAddress","change_admin","new_admin_address","mintTokens","amount","mintToAddress","mint_tokens","mint_to_address","burnTokens","burnFromAddress","burn_tokens","burn_from_address"],"mappings":"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"}